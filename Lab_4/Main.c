#include <stdio.h>
#include <malloc.h>

int** findIncrise(int arr[], int *size) {							//Функция, находящая последовательность подряд возрастащих значений и возвращающая их в видк массива указателей на линейные массивы
	int i = 0;														// Вспомогательные итераторыы
	int j = 0;
	int k = 1;
	int incrStart = 0;												//Индекс начала последовательности
	int incrFinish = 0;												//Индекс конца последовательности
	//int subArrSize = 0;												//
	int subSize = 0;												//Размер последовательности
	int m = 0;
	int** res = (int**)malloc(sizeof(int) * (*size) + *size);		//Результирующий массив указателей
	int* sizesTmp = (int*)malloc(sizeof(int) * (*size));			//Вспомогательный массив, содержащий размеры последовательностей
	int* rest = (int*)malloc(sizeof(int) * (*size));				//Вспомогательный массив, содержащий не возрастающие подряд значения
	int* tmp = (int)malloc(sizeof(int)* 5);							//Вспомогательный массив, хранящий возрастающую последовательность
	for (int i = 0; i < *size; i++) {								//Поиск последовательностей и заплнение массивов
			
		if (arr[i] < arr[i + 1]) {									//Если следующее число больше предыдущего
			tmp[j] = arr[i];										//То записываем текущее число во вспомогательный массив
			subSize++;												//Увеличиваем переменную с размером этого массива на 1
			j++;				
		}
		else if (subSize > 0) {										//Если число меньше или равно соедующему и размер вспомогательного массива больше 0
			subSize++;												//То увеличиваем размер массива на 1
			tmp[j] = arr[i];										//И записываем в него текущий элемент исходного массива
			j = 0;										
			res[k] = (int*)malloc(sizeof(int) * subSize);			//Выделяем количество памяти для массива, равный размеру поледовательности
			for (int m = 0; m < subSize; m++) {						//И записываем в него последовательность
				res[k][m] = tmp[m];
			}
			sizesTmp[k - 1] = subSize;								//Сохраняем размер последовательности во вспомогательном массиве
			subSize = 0;
			k++;
		}	
		else {														//Если число не меньще следующего
			rest[m] = arr[i];										//То записываем его в массив, зранящий не возрастающие подряд значения
			m++;
		}
	}
	if (m > 0) {													//Если его размер больше 0
		res[k] = (int*)malloc(sizeof(int) * m);						//То выделем под него память
		for (int i = 0; i < m; i++) {								//И заполняем
			res[k][i] = rest[i];
		}
	}
	res[0] = (int*)malloc(sizeof(int) * k);							//Выделяем память под массив с размерами последоватьельностей в результирующем массиве указателей
	res[0][k - 1] = m;												//В его конец записываем количество невозрастающих элементов( Если их нет, то 0)
	for (int i = 0; i < k - 1; i++) {								//Заполняем этот массив размерами последовательностей
		res[0][i] = sizesTmp[i];
	}

	for (int i = 0; i < k; i++) {									//Выводим количество последовательностей
		printf("%i ", res[0][i]);
	}
	printf("\n");
	for (int j = 0; j < k; j++) {									//Выводим последовательности
		for (int i = 0; i < res[0][j]; i++) {
			printf("%i ", res[j + 1][i]);
		}
		printf("\n");
	}
	*tmp = NULL;													//Очищаем динамически выделенную память
	free(*tmp);
	*sizesTmp = NULL;
	free(*sizesTmp);
	*rest = NULL;
	free(*rest);
	return res;														//Возвращаем результирующий массив
}

char** symmetry(char str[], int size, int* strings) {				//Функия, находящая элементы относительно центрального символа(При нечетных значениях размера стоки)
	if (size >= 7) {												// Если размер больше 7
		int count = 0;												//Счетчик подряд идущих симметричных значений
		char** res = (char**)malloc(sizeof(char) * size);			//Выделение память под результирующий массив указателей
		int j = size / 2;											//Индекс центрального элемента
		int symStart = 0;											//Индекс начала последовательности
		int k = 0;
		for (int i = 1; i < size / 2 + 1; i++) {					//Поиск симметричных символов
			if (str[j - i] == str[j + i] && j - i != 0) {			//Если символы симметричны и не являются крайними в строке
				if (count == 0) {									//И если количество подряд идущих симметричных символов = 0
					symStart = j - i;								//Запоминаем индекс начала этой последоввательности
				}
				count++;											//Увеличиваем размер последователь
			}
			else									
			{
				if (str[j - i] == str[j + i]) {						//Если символы симметричны и являются крайними
					symStart = 0;									//То указываем начало последовательности на 0 элемент строки
					count = 1;
					res[k] = (char*)malloc(sizeof(char) * count);	//Выделяем паямять под эту последовательность в результирующем массиве
					for (int i = 0; i < count; i++) {				//И заполняем его
						res[k][i] = str[symStart - i];
					}
					res[k][count] = '\0';							//Указываем конец строки
					k++;
					count = 0;										//Зануляем размер последовательности
				}else if (count != 0) {								//Если поледовательность последовательно идущих симметричных символов прервыается
					if (j - i == 0) {
						count++;
					}
					res[k] = (char*)malloc(sizeof(char) * count); //То выделяем память под нее и записываем ее в результирующий массив
					for (int i = 0; i < count; i++) {
						res[k][i] = str[symStart - i];
					}
					res[k][count] = '\0';
					k++;
					count == 0;
				}
			}
		}
		*strings = k;											//Количество последовательностей
	return res;													//Возвращаем результирующий массив
	}
	return 1;
}

int main() {
	int arr[] = {1, 7, 9, 2, 4, 1, 1, 2, 3, 0, 1, 0, 0};
	int size = sizeof(arr) / sizeof(int);
	int** res1 = findIncrise(arr, &size);
	**res1 = NULL;
	free(**res1);
	/*for (int i = 0; i < 5; i++) {
		printf(" %i", *(res + i));
	}*/
	char str[] = "acbbfbbma";
	int strings = 0;
	int** res = symmetry(str, sizeof(str) / sizeof(char) - 1, &strings);
	for (int i = 0; i < strings; i++) {
		printf("%s\n", res[i]);
	}
	**res = NULL;
	free(**res);
	return 0;
}